//实现 int sqrt(int x) 函数。
//
// 计算并返回 x 的平方根，其中 x 是非负整数。
//
// 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
//
// 示例 1:
//
// 输入: 4
//输出: 2
//
//
// 示例 2:
//
// 输入: 8
//输出: 2
//说明: 8 的平方根是 2.82842...,
//     由于返回类型是整数，小数部分将被舍去。
//
//

/**
 * @param {number} x
 * @return {number}
 */

/*
  二分法查找：
  思路分析：使用二分法搜索平方根的思想很简单，就类似于小时候我们看的电视节目中的“猜价格”游戏，高了就往低了猜，低了就往高了猜，范围越来越小。
  因此，使用二分法猜算术平方根就很自然。一个数的平方根肯定不会超过它自己，不过直觉还告诉我们，一个数的平方根最多不会超过它的一半，
  例如 8 的平方根，8 的一半是 4，4^2=16>8，如果这个数越大越是如此，因此我们要计算一下，这个边界是多少。为此，解如下不等式：(a / 2)^2 >= a
  意即：如果一个数的一半的平方大于它自己，那么这个数的取值范围。解以上不等式得 a≥4 或者 a≤0。
  于是边界值就是 44，那么对 00、11、22、33 分别计算结果，很容易知道，这 44 个数的平方根依次是 00、11、11、11。
  注意：这 44 个特值如果没有考虑到，有可能导致你设置的搜索边界不正确。在使用二分法寻找平方根的时候，要特别注意边界值的选择。
  时间复杂度：O(logN)
  空间复杂度：O(1)
 */

var mySqrt = function(x) {
  if (x === 0) { // 0 - 4 的值需要特殊处理
    return 0
  } else if (x < 4) {
    return 1
  }
  let left = 1
  let right = x / 2 + 1 // 取x范围中间靠后位置
  while (left < right) {
    // 注意：这里一定取右中位数，如果取左中位数，代码会进入死循环
    let mid = (left + right + 1) >>> 1 // 取缩减对半范围后的中间靠后值
    const square = mid * mid // 猜x的平方根跟中间靠后值的平方对比，每次缩小一半距离
    if (square > x) {
      right = mid - 1 // 往左边缩减范围
    } else {
      left = mid // 往右边缩减范围
    }
  }
  return left
};

/*
  牛顿迭代法：曲线 f(x) = x ^ 2 - a 中取切线 f(x) = (x + a / x) / 2 无限接近于 x 的值
  时间复杂度：O(logN)
  空间复杂度：O(1)
 */
var mySqrt = function(x) {
  let ans = x
  while (ans * ans > x) {
    ans = parseInt((ans + x / ans) / 2)
  }
  return ans
};

const x = 9
console.log(mySqrt(x));
